# [Quest 05. OOP 특훈](https://github.com/Knowre-Dev/WebDevCurriculum/tree/master/Quest05)

# 1. 관심사의 분리 원칙이란 무엇인가요? 웹에서는 이러한 원칙이 어떻게 적용되나요?

- 프로그램을 관심사 별로 쪼개서 가능하면 한 번에 한 가지 걱정만 함으로써 유지보수 시의 복잡성을 줄이는 것을 말한다.

<br />

## 🧐 웹 에서의 관심사의 분리 원칙

- HTML과 CSS의 분리
    - 마크업에서 프레젠테이션 클래스 등의 특정 요소나 구성 요소의 모양을 정의하는 경우가 있는데, 이를 Sass를 사용하면서 Mixin을 사용하면 HTML과 CSS를 분리할 수 있다.
    
     
    
    ```jsx
    // 아래 마크업에서는 요소가 무엇인지, CSS요소까지 정하고 있다.
    <div class="my-element col-lg-3 col-md-4 col-sm-6 col-xs-12">
    
    // 아래 마크업은 요소가 무엇인지만 정의하고 CSS는 분리한다.
    <div class="my-element">
    
    // Sass
    .my-element {
        @include col-lg(3);
        @include col-md(4);
        @include col-sm(6);
        @include col-xs(12);
    }
    ```
    

- CSS와 Javascript의 분리
    - Javascript로 class 등을 변경하다 의미적으로나 CSS를 의도하지 않게 변경할 수도 있다.
    - 이 경우 `js-` 접두사를 붙여서 해당 ID 또는 Class가 Javascript 대상이 되고 있음을 나타내어 CSS와 Javascript를 분리할 수 있다.
    
    ```jsx
    <div class="my-element js-my-element">
    ```
    

<br />

# 2. 객체지향의 SOLID 원칙이란 무엇인가요? 이 원칙을 구체적인 예를 들어 설명할 수 있나요?

```
S : Single Responsibility Principle (단일 책임 원칙)
O : Open-Closed Principle  (개방 폐쇄 원칙)
L : Liskov Substitution Principle  (리스코프 치환 원칙)
I : Interface Segregation Principle  (인터페이스 분리 원칙)
D : Dependency Inversion Principle (의존성 역전 원칙)
```

<br />

## 2-1) S(단일 책임 원칙)

- 하나의 클래스에 모든 동작을 넣으면 시스템은 점점 비대해지고 한 부분에서 에러가 발생하면 전체가 무너진다.
- **S원칙**은 어떠한 경우에도 클래스는 단일 책임지도록 하여 문제가 발생했을 때 책임 범위를 쉽게 파악할 수 있게 한다.

<br />

## 2-2) O(개방 폐쇄 원칙)

- 객체지향 5원칙과 20개가 넘는 디자인패턴을 사용하는 궁극적인 목표는 **효율성**이다.
- O원칙은 클래스를 만들면서 **공통된 개념**의 기능이 있다면 **하나로 엮고**, 하위 클래스에서 구체적인 내용을 구현한다. ⇒ 마치 아웃소싱 한다는 개념으로 클래스를 작성하면 **최대한 효율**적인 코드를 작성할 수 있다.

<br />

## 2-3) L(리스코프 치환 원칙)

- 치환성은 객체 지향 프로그래밍 원칙으로 프로그램에서 자료형 (a)가 자료형 (A)의 하위형이라면 필요한 프로그램의 속성의 변경 없이 자료형 (A)의 객체를 자료형 (a)의 객체로 교체할 수 있어야 한다는 원칙이다.
- 리스코프 치환 원칙을 사용하는 것은 **복제**와 관련이 깊다. ⇒ 복제가 갖는 **효율성**에 기원한다.
- extends 키워드를 사용하여 클래스를 상속받고, super() 메서드를 통해 상위 클래스의 특징을 복제할 수 있다.
- 부모에게서 물려받은 메서드명은 일치시키고 내용을 다르게 작성한다.**(리스코프 치환)**

<br />

## 2-4) I(인터페이스 분리 원칙)

- 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 **원칙**이다
- 큰 덩어리의 **인터페이스**들을 구체적이고 작은 단위들로 **분리**시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다.
- 인터페이스는 서로 간섭을 일으키지 않아야 하고, 내부의 동작과 직접적으로 연결되어서도 안 된다.
- 인터페이스를 설계할 때 다음 분리 원칙을 따른다.
    1. 기능을 구현한다
    2. 사용자의 요구에 맞춰 기능을 분리한다(인터페이스 생성)
    3. 인터페이스 간섭이 발견되면 분리한다

<br />

## 2-5) D(의존성 역전 원칙)

- 의존성이 역전되면 안 된다.
- 객체지향 프로그램에서 어떠한 경우에도 인터페이스가 중앙시스템에 직접 접근을 해서는 안된다. ⇒ 인터페이스 클래스와 중앙시스템 사이에 대리인 클래스가 존재해야 한다.
- 인터페이스를 분리만 했을 뿐, 메인 시스템과 강하게 연결되어 있으면 시스템이 붕괴되는 건 시간문제다.

<br />

# 3. 로컬 스토리지란 무엇인가요? 로컬 스토리지의 내용을 개발자 도구를 이용해 확인하려면 어떻게 해야 할까요?

- 로컬 스토리지는 데이터를 로컬 저장 공간인 Storage 객체에 저장하여 브라우저 세션 간에 공유된다.
- 로컬 스토리지의 데이터는 만료되지 않고, 세션 스토리지는 브라우저 세션이 만료되었을 때(페이지를 닫을 때) 삭제된다.
- 개발자 도구 → application → Storage 탭에 Local Storage에서 확인할 수 있다.