# Quest 12. 보안의 기초

# 1. 입력 데이터의 Validation을 웹 프론트엔드에서 했더라도 서버에서 또 해야 할까요? 그 이유는 무엇일까요?

- 프론트 엔드, 서버에서 둘 다 유효성 검사(Validation)을 해야한다.

<br />

**이유**

- 만약 회원가입에 대해 프론트 엔드에서만 유효성 검사가 이루어지면 표면적으로는 아무런 문제가 없어보일 수 있다.
- 다만, 브라우저 개발자 도구에서 회원가입을 누르기 직전 콘솔을 통해 데이터를 변경하면 유효성 검사를 피해갈 수 있다. ⇒ 사실상 프론트에서의 유효성 검사는 UI/UX를 위한 것이라고 볼 수도 있다.
- 따라서, 프론트 엔드에서 계정 길이, 암호 길이, 그 외 특수문자 등 유효성 검사를 한 결과를 넘겨주고, 개발자 도구 등으로 유효성 검사를 피해갈 수 있는 상황에 대해서는 서버에서 진행해 주는 것이 좋다.

<br />

## 1-1) 서버로부터 받은 HTML 내용을 그대로 검증 없이 프론트엔드에 innerHTML 등을 통해 적용하면 어떤 문제점이 있을까요?

- 검증없이 그대로 innerHTML 을 통해 적용하면 XSS 공격 등 보안에 취약해질 수 있다.
- 서버에서 받은 데이터와 동작 자체는 보여지지 않지만, HTML을 통해 그대로 적용하게 되면 XSS 공격을 통해 악의적인 스크립트를 실행시켜 개인 정보를 탈취할 수 있는 가능성이 생기게 된다.

<br />

## 1-2) XSS(Cross-site scripting)이란 어떤 공격기법일까요?

- 악의적인 사용자가 공격하려는 사이트에 악성 스크립트를 삽입하는 공격 기법이다.
- 관리자가 아닌 권한이 없는 사용자가 웹 사이트에 스크립트를 삽입해서 서버로 리다이렉트 하거나 사용자의 쿠키, 세션 등을 탈취하여 악성 스크립트를 설치하거나 정보를 탈취할 수 있다.

<br />

### 1) Stored XSS

- 공격자는 웹 어플리케이션에서 XSS 취약점이 있는 곳을 파악하고 악성스크립트를 삽입한다.
- 삽입된 스크립트는 데이터베이스에 저장되고, 해당 스크립트가 있는 게시글 등을 열람한 사용자는 쿠키를 탈취 당하거나 다른 사이트로 리다이렉션되는 공격을 받게 된다.
- 데이터베이스에 저장돼 지속적으로 공격한다고 해서 Persistent XSS 또는 Stored XSS라고 부른다.

<br />

### 2) Reflected XSS

- 사용자에게 입력 받은 값을 서버에서 되돌려 주는 곳에서 발생한다.
- 검색이나 입력값 등에 대해 응답을 받을 때 스크립트가 실행된다.
- 보통 악의적인 스크립트와 함께 URL을 사용자에게 누르도록 유도하고, URL을 누른 사용자는 악의적인 스크립트가 실행되면서 공격을 당하게 된다.
- 링크를 클릭한 사용자는 본인의 의도와 상관 없이 쿠키 값 등을 전송하게 된다.

<br />

### 3) DOM based XSS

- 악의적인 스크립트가 포함된 URL을 사용자가 요청하게 되어 브라우저를 해석하는 단계에서 발생하는 공격이다.
- 클라이언트 측 코드가 원래 의도와는 다르게 실행된다.
- 서버에서 탐지가 어렵다.

<br />

## 1-3) CSRF(Cross-site request forgery)이란 어떤 공격기법일까요?

- 인터넷 사용자(희생자)가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 만드는 공격
    - 예를들어, 페이스북에 희생자의 계정으로 광고성 글을 올리는 것

<br />

**공격 예시**

```html
<img src="http://CSRF/changeUserAcoount?id=admin&password=admin" width="0" height="0">
```

1. 관리자 중 한명이 관리 권한을 가지고 회사내에서 작업을 하던 중 메일을 조회한다. (로그인이 이미 되어있다고 가정하면 관리자로서의 유효한 쿠키를 갖고있음)
2. 해커는 악의적인 HTML 태그가 들어간 코드가 담긴 이메일을 보낸다. 관리자는 이미지 크기가 0이므로 전혀 알지 못한다.
3. 피해자가 이메일을 열어볼 때, 이미지 파일을 받아오기 위해 URL이 열린다.
4. 해커가 원하는 대로 관리자의 계정이 id와 pw 모두 admin인 계정으로 변경된다.

<br />

## 1-4) SQL Injection이란 어떤 공격기법일까요?

- SQL Injection 이란 악의적인 사용자가 보안상의 취약점을 이용하여, 임의의 SQL 문을 주입하고 실행되게 하여 데이터베이스가 비정상적인 동작을 하도록 조작하는 행위

<br />

# 2. 대부분의 최신 브라우저에서는 HTTP 대신 HTTPS가 권장됩니다. 이유가 무엇일까요?

- HTTP는 서버에서 브라우저로 전송되는 정보가 암호화되지 않는다는 문제점을 가지고 있다.
    
    ⇒ 데이터가 쉽게 도난당할 수 있다.
    
- HTTPS는 SSL(보안 소켓 계층)을 사용하여 암호화된 연결을 만들 수 있게 도와주고, 서버와 클라이언트가 민감한 정보를 주고받을 때 해당 정보가 도난당하는 것을 막아준다.
- HTTPS로 데이터를 전송하게 되면 데이터 원본 자체가 아닌 암호화된 데이터를 전송하게 되고, 이 데이터가 어떤 내용을 가지고 있는지 알기가 어려워진다.

<br />

## 2-1) HTTPS와 TLS는 어떤 식으로 동작하나요? HTTPS는 어떤 역사를 가지고 있나요?

- **SSL(Secure Sockets Layer)**: Netscape에서 웹 서버와 웹 브라우저간의 보안을 위해 만든 프로토콜로 공개키/개인키, 대칭키 기반으로 사용한다.
    - **대칭키**: 동일한 키로 암호화와 복호화를 수행하는 방법
        - 해커가 대칭키를 갖고 있으면 암호화된 데이터를 가로채 쉽게 데이터를 확인할 수 있다.
    - **공개키/개인키**: 서로 다른 키로 암호화, 복호화를 수행하는 방법
        - 해커가 공개키를 가지고 있더라도 개인키가 없으면 데이터를 복호화할 수 없기 때문에 암호화된 데이터를 가로채도 확인할 수 없다.

<br />

- TLS(Transport Layer Security): SSL 3.0을 기반으로 발전되었으나 TLS와 SSL은 상호 운영되지 않는다.
- 클라이언트와 서버 둘 다의 인증 동안에 **비대칭 키(공개키/개인키)** 쌍 중 하나로 데이터가 암호화되고 해당 쌍의 다른 키로 비밀번호가 복호화되어야 하는 단계가 있다.

<br />

**동작**

1. 클라이언트가 서버에 ClientHello 메세지를 보낸다.(TLS 버전, 도메인, 세션 식별자, 암호 등)
2. 서버에서는 ServerHello 메세지를 클라이언트에게 보낸다.(TLS 버전, 세션 식별자, 암호 등)
3. 서버가 클라이언트에 Certificate 메세지를 보낸다. 여기서 서버의 인증서가 들어가고 이 서버가 신뢰할 수 있는 자임을 인증한다.
4. 클라이언트는 서버에서 받은 인증서를 검증한다. ⇒ 만료 기간, 해당 서버에서 발급된 인증서인지 여부, 등 신뢰할 수 있다고 판단되면 다음 단계로 넘어간다.
5. 클라이언트는 임의 pre-master secret을 생성한뒤 서버가 보낸 인증서에 공개키를 사용해 암호화한 후 서버로 전송한다.
6. 서버는 전송받은 정보를 복호화하여 pre-master secret을 알아낸 뒤 이 정보를 이용해 master secret을 생성한다.
7. 서버와 클라이언트는 각각의 master secret에서 세션 키를 생성하고 서버와 클라이언트 간 통신을 암호화하는데 사용한다.
8. 서버와 클라이언트는 동일한 세션 키를 갖고 보안 통신이 구성된다.